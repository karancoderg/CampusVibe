# CampusConnect Backend Design Document

## Architecture Overview

### Backend Stack
- **Database:** Supabase PostgreSQL
- **Authentication:** Supabase Auth
- **Real-time:** Supabase Realtime
- **Storage:** Supabase Storage
- **API:** Auto-generated REST + Custom Functions

### System Architecture
```
Frontend (React) 
    ↓ HTTP/WebSocket
Supabase Edge Functions (Optional Custom Logic)
    ↓
Supabase Database (PostgreSQL + RLS)
    ↓
Supabase Storage (Files/Images)
```

## Database Design

### Core Tables Structure
```sql
-- User profiles extending auth.users
profiles (id, username, display_name, avatar_url, bio, university, year, location)

-- Social features
posts (id, user_id, community_id, type, content, mood, likes, comments)
communities (id, name, description, category, member_count, trending)
post_likes (user_id, post_id) -- Many-to-many for likes
post_comments (id, post_id, user_id, content, created_at)

-- Events system
events (id, title, description, organizer_id, location, event_date, attendees)
event_attendees (user_id, event_id, status) -- 'attending', 'maybe', 'not_going'

-- Chat system
chat_rooms (id, name, type, last_message, created_at)
chat_participants (chat_id, user_id, joined_at)
messages (id, chat_id, user_id, content, type, created_at)

-- Skills & wellness
user_skills (id, user_id, category, name, level, trend)
wellness_entries (id, user_id, type, value, date) -- mood, goals, sleep
achievements (id, user_id, title, description, earned_at)

-- Study features
study_notes (id, user_id, chat_id, title, content, subject, tags)
```

### Relationships & Constraints
- **One-to-Many:** users → posts, events, messages
- **Many-to-Many:** users ↔ communities, users ↔ events, users ↔ chat_rooms
- **Foreign Keys:** All references with CASCADE deletes where appropriate
- **Unique Constraints:** usernames, community names, chat participants

## API Design

### Authentication Endpoints
```javascript
// Supabase Auth handles these automatically
POST /auth/v1/signup
POST /auth/v1/token (login)
POST /auth/v1/logout
GET /auth/v1/user (get current user)
```

### Core API Endpoints (Auto-generated by Supabase)
```javascript
// Posts
GET /rest/v1/posts?select=*,profiles(*),communities(*)&order=created_at.desc
POST /rest/v1/posts
PATCH /rest/v1/posts?id=eq.{id}
DELETE /rest/v1/posts?id=eq.{id}

// Communities
GET /rest/v1/communities?select=*
POST /rest/v1/communities
GET /rest/v1/communities?id=eq.{id}&select=*,posts(*)

// Events
GET /rest/v1/events?select=*,profiles(*)&order=event_date.asc
POST /rest/v1/events
POST /rest/v1/event_attendees

// Chat
GET /rest/v1/chat_rooms?select=*,chat_participants(profiles(*))
POST /rest/v1/messages
GET /rest/v1/messages?chat_id=eq.{id}&order=created_at.desc
```

### Custom Database Functions
```sql
-- Increment post likes atomically
CREATE OR REPLACE FUNCTION increment_likes(post_id UUID)
RETURNS void AS $$
BEGIN
  UPDATE posts SET likes = likes + 1 WHERE id = post_id;
END;
$$ LANGUAGE plpgsql;

-- Get user feed with pagination
CREATE OR REPLACE FUNCTION get_user_feed(
  user_id UUID,
  page_size INT DEFAULT 20,
  page_offset INT DEFAULT 0
)
RETURNS TABLE(
  post_id UUID,
  content TEXT,
  created_at TIMESTAMP,
  author_name TEXT,
  community_name TEXT,
  likes INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.content,
    p.created_at,
    pr.display_name,
    c.name,
    p.likes
  FROM posts p
  JOIN profiles pr ON p.user_id = pr.id
  LEFT JOIN communities c ON p.community_id = c.id
  ORDER BY p.created_at DESC
  LIMIT page_size OFFSET page_offset;
END;
$$ LANGUAGE plpgsql;

-- Search posts and users
CREATE OR REPLACE FUNCTION search_content(search_term TEXT)
RETURNS TABLE(
  type TEXT,
  id UUID,
  title TEXT,
  content TEXT,
  relevance FLOAT
) AS $$
BEGIN
  RETURN QUERY
  -- Search posts
  SELECT 
    'post'::TEXT,
    p.id,
    ''::TEXT,
    p.content,
    ts_rank(to_tsvector('english', p.content), plainto_tsquery('english', search_term))
  FROM posts p
  WHERE to_tsvector('english', p.content) @@ plainto_tsquery('english', search_term)
  
  UNION ALL
  
  -- Search users
  SELECT 
    'user'::TEXT,
    pr.id,
    pr.display_name,
    pr.bio,
    ts_rank(to_tsvector('english', pr.display_name || ' ' || COALESCE(pr.bio, '')), plainto_tsquery('english', search_term))
  FROM profiles pr
  WHERE to_tsvector('english', pr.display_name || ' ' || COALESCE(pr.bio, '')) @@ plainto_tsquery('english', search_term)
  
  ORDER BY relevance DESC;
END;
$$ LANGUAGE plpgsql;
```

## Security Design

### Row Level Security (RLS) Policies
```sql
-- Posts: Public read, authenticated write
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "posts_select" ON posts FOR SELECT USING (true);
CREATE POLICY "posts_insert" ON posts FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "posts_update" ON posts FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "posts_delete" ON posts FOR DELETE USING (auth.uid() = user_id);

-- Chat: Only participants can access
CREATE POLICY "chat_access" ON messages FOR ALL USING (
  EXISTS (
    SELECT 1 FROM chat_participants 
    WHERE chat_id = messages.chat_id AND user_id = auth.uid()
  )
);

-- Private data: Only owner access
CREATE POLICY "wellness_privacy" ON wellness_entries FOR ALL USING (auth.uid() = user_id);
CREATE POLICY "notes_privacy" ON study_notes FOR ALL USING (auth.uid() = user_id);
```

### Data Validation
```sql
-- Check constraints for data integrity
ALTER TABLE posts ADD CONSTRAINT posts_content_length CHECK (length(content) <= 2000);
ALTER TABLE profiles ADD CONSTRAINT profiles_username_format CHECK (username ~ '^[a-zA-Z0-9_]{3,20}$');
ALTER TABLE wellness_entries ADD CONSTRAINT wellness_value_range CHECK (
  (type = 'mood' AND value IN ('happy', 'sad', 'anxious', 'calm', 'excited', 'stressed')) OR
  (type = 'sleep' AND value::numeric BETWEEN 0 AND 24)
);
```

## Real-time Features

### WebSocket Subscriptions
```javascript
// Real-time post updates
supabase
  .channel('posts')
  .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'posts' }, handleNewPost)
  .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'posts' }, handlePostUpdate)
  .subscribe()

// Real-time chat messages
supabase
  .channel(`chat:${chatId}`)
  .on('postgres_changes', { 
    event: 'INSERT', 
    schema: 'public', 
    table: 'messages',
    filter: `chat_id=eq.${chatId}`
  }, handleNewMessage)
  .subscribe()

// User presence tracking
supabase
  .channel('online_users')
  .on('presence', { event: 'sync' }, () => {
    const state = supabase.getChannels()[0].presenceState()
    // Update online users list
  })
  .subscribe()
```

## File Storage Design

### Storage Buckets
```sql
-- Public buckets for avatars and post images
INSERT INTO storage.buckets (id, name, public) VALUES 
  ('avatars', 'avatars', true),
  ('post-images', 'post-images', true),
  ('community-banners', 'community-banners', true);

-- Private bucket for study materials
INSERT INTO storage.buckets (id, name, public) VALUES 
  ('study-files', 'study-files', false);
```

### Storage Policies
```sql
-- Users can upload their own avatars
CREATE POLICY "avatar_upload" ON storage.objects FOR INSERT WITH CHECK (
  bucket_id = 'avatars' AND 
  auth.uid()::text = (storage.foldername(name))[1]
);

-- Authenticated users can upload post images
CREATE POLICY "post_images_upload" ON storage.objects FOR INSERT WITH CHECK (
  bucket_id = 'post-images' AND 
  auth.role() = 'authenticated'
);
```

## Performance Optimizations

### Database Indexes
```sql
-- Critical indexes for performance
CREATE INDEX CONCURRENTLY idx_posts_feed ON posts(created_at DESC, user_id);
CREATE INDEX CONCURRENTLY idx_messages_chat ON messages(chat_id, created_at DESC);
CREATE INDEX CONCURRENTLY idx_events_date ON events(event_date) WHERE event_date >= NOW();
CREATE INDEX CONCURRENTLY idx_search_posts ON posts USING gin(to_tsvector('english', content));
CREATE INDEX CONCURRENTLY idx_search_profiles ON profiles USING gin(to_tsvector('english', display_name || ' ' || COALESCE(bio, '')));
```

### Caching Strategy
- **Browser Cache:** Static assets (avatars, images) with long TTL
- **Supabase Edge Cache:** Frequently accessed data (community lists, user profiles)
- **Client-side Cache:** React Query for API responses with stale-while-revalidate

## Monitoring & Analytics

### Activity Tracking
```sql
-- Log user actions for analytics
CREATE TABLE activity_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES profiles(id),
  action TEXT NOT NULL,
  resource_type TEXT,
  resource_id UUID,
  metadata JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Trigger to log post creation
CREATE OR REPLACE FUNCTION log_post_creation()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO activity_logs (user_id, action, resource_type, resource_id, metadata)
  VALUES (NEW.user_id, 'post_created', 'post', NEW.id, 
    jsonb_build_object('type', NEW.type, 'community_id', NEW.community_id));
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER post_creation_log AFTER INSERT ON posts
FOR EACH ROW EXECUTE FUNCTION log_post_creation();
```

## Deployment Architecture

### Environment Setup
```bash
# Production environment variables
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-key (server-side only)

# Database connection for migrations
DATABASE_URL=postgresql://postgres:[password]@db.[project].supabase.co:5432/postgres
```

### Migration Strategy
```sql
-- Migration files structure
migrations/
├── 001_initial_schema.sql
├── 002_add_indexes.sql
├── 003_rls_policies.sql
├── 004_custom_functions.sql
└── 005_activity_logging.sql
```

### Backup & Recovery
- **Automated Backups:** Supabase handles daily backups
- **Point-in-time Recovery:** Available for 7 days
- **Data Export:** Regular exports of critical data to external storage

## API Rate Limiting & Security

### Rate Limiting
```sql
-- Custom rate limiting function
CREATE OR REPLACE FUNCTION check_rate_limit(
  user_id UUID,
  action_type TEXT,
  max_requests INT,
  time_window INTERVAL
)
RETURNS BOOLEAN AS $$
DECLARE
  request_count INT;
BEGIN
  SELECT COUNT(*) INTO request_count
  FROM activity_logs
  WHERE user_id = check_rate_limit.user_id
    AND action = action_type
    AND created_at > NOW() - time_window;
  
  RETURN request_count < max_requests;
END;
$$ LANGUAGE plpgsql;
```

### Input Sanitization
- **SQL Injection:** Prevented by Supabase's parameterized queries
- **XSS Protection:** Content sanitization on frontend
- **File Upload Security:** MIME type validation, size limits
- **Authentication:** JWT token validation on all protected routes

## Scalability Considerations

### Database Scaling
- **Read Replicas:** For read-heavy operations
- **Connection Pooling:** Supabase handles automatically
- **Query Optimization:** Regular EXPLAIN ANALYZE on slow queries

### Horizontal Scaling
- **Stateless Design:** All state in database, no server-side sessions
- **CDN Integration:** Supabase Storage with global CDN
- **Edge Functions:** For custom business logic near users

This backend design provides a robust, scalable foundation for CampusConnect using Supabase's managed infrastructure while maintaining flexibility for custom business logic.
